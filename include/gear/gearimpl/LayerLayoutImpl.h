// -*- C++ -*-
// AID-GENERATED
// =========================================================================
// This class was generated by AID - Abstract Interface Definition          
// DO NOT MODIFY, but use the org.freehep.aid.Aid utility to regenerate it. 
// =========================================================================
#ifndef GEAR_LayerLayoutImpl_H
#define GEAR_LayerLayoutImpl_H 1


#include "gear/LayerLayout.h"
#include <vector>


namespace gear {
  
  /** Implementation of  layered layout detector - typically a 
   *  a sampling calorimeter.
   * 
   * @author F. Gaede, DESY
   * @version $Id$
   */

  class LayerLayoutImpl : public LayerLayout {
    
  public: 
    
    /** Helper class for layer properties */
    struct Layer {
      double Distance{};
      double Thickness {};
      double AbsorberThickness {};
      double CellSize0 {};
      double CellSize1 {};
    } ;
    
    typedef std::vector<Layer> LayerVec ;
    
    /// Destructor.
    virtual ~LayerLayoutImpl() { /* nop */; }
    
    /** The total number of layers.
     */
    virtual int getNLayers() const { return _vec.size()  ; }
    
    /** The distance of the layer layerIndex from the origin - layer indexing starts at 0
     *  for the layer closest to the origin.
     */ 
    virtual double getDistance(int layerIndex) const { return _vec.at( layerIndex ).Distance  ; }
    
    /** The thickness of the layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the origin.
     */ 
    virtual double getThickness(int layerIndex) const { return _vec.at( layerIndex ).Thickness  ; }
    
    /** The thickness of the absorber part of the layer layerIndex - layer indexing starts at 0
     *  for the layer closest to the origin.
     */ 
    virtual double getAbsorberThickness(int layerIndex) const { 
      return _vec.at( layerIndex ).AbsorberThickness  ; 
    }
    
    /** The cell size along the first axis where first is either along the beam (barrel type) or up (endcap)
     * or the direction closest to that.   
     */ 
    virtual double getCellSize0(int layerIndex) const {
      return _vec.at( layerIndex ).CellSize0  ; 
    }

    /** The second cell size, perpendicular to the first direction (getCellSize0()) and the depth of the layers.
     */ 
    virtual double getCellSize1(int layerIndex) const {
      return _vec.at( layerIndex ).CellSize1  ; 
    }

    /** Position new layer at the given distance (after the last layer) - typically this will be used for
     *  the first layer. 
     */
    virtual void positionLayer(double distance, double thickness, double cellSize0, double cellSize1, double absorberThickness = 0. ) ; 

    /** Add a new layer right after the last layer - at distance 0. mm if first layer.  
     */
    virtual void addLayer(double thickness, double cellSize0, double cellSize1, double absorberThickness = 0. ) ; 

  protected:
    LayerVec _vec{} ;
    
  }; // class

} // namespace gear

#endif /* ifndef GEAR_LayerLayoutImpl_H */
